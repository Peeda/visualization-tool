{
    "ArrayList": {
        "addFB": {
            "code": [
                ["procedure addFront(data)"],
                ["  addAtIndex(0, data)"],
                ["end procedure"],
                [""],
                ["procedure addBack(data)"],
                ["  addAtIndex(size, data)"],
                ["end procedure"]
            ],
            "english": [
                ["procedure addFront(data)"],
                ["  call addAtIndex at front with data"],
                ["end procedure"],
                [""],
                ["procedure addBack(data)"],
                ["  call addAtIndex at back with data"],
                ["end procedure"]
            ]
        },
        "addIndex": {
            "code": [
                ["procedure addAtIndex(index, data)"],
                ["  if size == array.length"],
                ["    T[] newArray ← new array[size * 2]"],
                ["    for i ← 0 to index - 1, i++:"],
                ["      newArray[i] ← array[i]"],
                ["    newArray[index] ← data"],
                ["    for i ← index to size - 1, i++:"],
                ["      newArray[i + 1] ← array[i]"],
                ["    array ← newArray"],
                ["  else"],
                ["    for i ← size to index + 1, i--:"],
                ["      array[i] ← array[i - 1]"],
                ["    array[index] ← data"],
                ["  size++"],
                ["end procedure"]
            ],
            "english": [
                ["procedure addAtIndex(index, data)"],
                ["  if (at max capacity):"],
                ["    create newArray with 2x capacity"],
                ["    for (i from 0 to index):"],
                ["      copy array value at i to newArray"],
                ["    put data into newArray at index"],
                ["    for (i from index to back):"],
                ["      copy and shift array value at i to newArray"],
                ["    array points to newArray"],
                ["  else:"],
                ["    for (i from back to spot after index):"],
                ["      shift array value back"],
                ["    put data into array at index"],
                ["  increment size"],
                ["end procedure"]
            ]
        },
        "removeFB": {
            "code": [
                ["procedure removeFront()"],
                ["  removeFromIndex(0)"],
                ["end procedure"],
                [""],
                ["procedure removeBack()"],
                ["  removeFromIndex(size - 1)"],
                ["end procedure"]
            ],
            "english": [
                ["procedure removeFront()"],
                ["  call removeFromIndex at front"],
                ["end procedure"],
                [""],
                ["procedure removeBack()"],
                ["  call removeFromIndex at back"],
                ["end procedure"]
            ]
        },
        "removeIndex": {
            "code": [
                ["procedure removeFromIndex(index)"],
                ["  T data ← array[index]"],
                ["  array[index] ← null"],
                ["  for i ← index to size - 2, i++:"],
                ["    array[i] ← array[i + 1]"],
                ["  array[size - 1] ← null"],
                ["  size--"],
                ["  return data"],
                ["end procedure"]
            ],
            "english": [
                ["procedure removeFromIndex(index)"],
                ["  copy data at index to temp"],
                ["  for (i from index to spot before back):"],
                ["    copy array value at i and shift to newArray"],
                ["  null out back of array"],
                ["  decrement size"],
                ["  return temp"],
                ["end procedure"]
            ]
        }
    },
    "DoublyLinkedList": {
        "addFront": {
            "code": [
                ["procedure addFront(data)"],
                ["  if size == 0"],
                ["    head ← new Node(data)"],
                ["    tail ← head"],
                ["  else"],
                ["    Node newHead ← new Node(data)"],
                ["    newHead.next ← head"],
                ["    head.prev ← newHead"],
                ["    head ← newHead"],
                ["  size++"],
                ["end procedure"]
            ],
            "english": [
                ["procedure addFront(data)"],
                ["  if (list is empty):"],
                ["    head points to new node"],
                ["    tail points to new node"],
                ["  else:"],
                ["    create newHead node with data"],
                ["    newHead.next points to head"],
                ["    head.prev points to newHead"],
                ["    head points to newHead"],
                ["  increment size"],
                ["end procedure"]
            ]
        },
        "addBack": {
            "code": [
                ["procedure addBack(data)"],
                ["  if size == 0"],
                ["    tail ← new Node(data)"],
                ["    head ← tail"],
                ["  else"],
                ["    Node newTail ← new Node(data)"],
                ["    newTail.prev ← tail"],
                ["    tail.next ← newTail"],
                ["    tail ← newTail"],
                ["  size++"],
                ["end procedure"]
            ],
            "english": [
                ["procedure addBack(data)"],
                ["  if (list is empty):"],
                ["    head points to new node"],
                ["    tail points to new node"],
                ["  else:"],
                ["    create newTail node with data"],
                ["    newTail.prev points to tail"],
                ["    tail.next points to newTail"],
                ["    tail points to newTail"],
                ["  increment size"],
                ["end procedure"]
            ]
        },
        "addIndex": {
            "code": [
                ["procedure addAtIndex(index, data)"],
                ["  if index == 0"],
                ["    addFront(data)"],
                ["  else if index == size"],
                ["    addBack(data)"],
                ["  else"],
                ["    if index < size / 2"],
                ["      Node curr ← head"],
                ["      for i ← 0 to index - 2, i++:"],
                ["        curr = curr.next"],
                ["    else"],
                ["      Node curr ← tail"],
                ["      for i ← size - 1 to index, i--:"],
                ["        curr = curr.prev"],
                ["    Node newNode ← new Node(data)"],
                ["    newNode.prev ← curr"],
                ["    newNode.next ← curr.next"],
                ["    curr.next ← newNode"],
                ["    newNode.next.prev ← newNode"],
                ["    size++"],
                ["end procedure"]
            ],
            "english": [
                ["procedure addAtIndex(index, data)"],
                ["  if (index is at the front):"],
                ["    call addFront with data"],
                ["  else if (index is at the back):"],
                ["    call addBack with data"],
                ["  else:"],
                ["    if (index is closer to front):"],
                ["      curr points to head"],
                ["      for (i from 0 to node before index):"],
                ["        curr moves to next node"],
                ["    else:"],
                ["      curr points to tail"],
                ["      for (i from back to index):"],
                ["        curr moves to previous node"],
                ["    create newNode node with data"],
                ["    newNode.prev points to curr"],
                ["    newNode.next points to curr.next"],
                ["    curr.next points to newNode"],
                ["    newNode.next.prev points to newNode"],
                ["    increment size"],
                ["end procedure"]
            ]
        },
        "removeFront": {
            "code": [
                ["procedure removeFront()"],
                ["  T data ← head.data"],
                ["  head ← head.next"],
                ["  if head == null"],
                ["    tail ← null"],
                ["  else"],
                ["    head.prev ← null"],
                ["  size--"],
                ["  return data"],
                ["end procedure"]
            ],
            "english": [
                ["procedure removeFront()"],
                ["  copy data at head to temp"],
                ["  head moves to next node"],
                ["  if (head is null):"],
                ["    null out tail"],
                ["  else:"],
                ["    null out head.prev"],
                ["  decrement size"],
                ["  return temp"],
                ["end procedure"]
            ]
        },
        "removeBack": {
            "code": [
                ["procedure removeBack()"],
                ["  T data ← tail.data"],
                ["  tail ← tail.prev"],
                ["  if tail == null"],
                ["    head ← null"],
                ["  else"],
                ["    tail.next ← null"],
                ["  size--"],
                ["  return data"],
                ["end procedure"]
            ],
            "english": [
                ["procedure removeBack()"],
                ["  copy data at tail to temp"],
                ["  tail moves to previous node"],
                ["  if (tail is null):"],
                ["    null out head"],
                ["  else:"],
                ["    null out tail.next"],
                ["  decrement size"],
                ["  return temp"],
                ["end procedure"]
            ]
        },
        "removeIndex": {
            "code": [
    			["procedure removeFromIndex(index)"],
                ["  if index == 0"],
                ["    removeFront()"],
                ["  else if index == size - 1"],
                ["    removeBack()"],
                ["  else"],
                ["    if index < size / 2"],
                ["      Node curr ← head"],
                ["      for i ← 0 to index - 1, i++:"],
                ["        curr ← curr.next"],
                ["    else"],
                ["      Node curr ← tail"],
                ["      for i ← size - 1 to index + 1, i--:"],
                ["         curr ← curr.prev"],
                ["    T data ← curr.data"],
                ["    curr.prev.next ← curr.next"],
                ["    cur.next.prev ← curr.prev"],
                ["    size--"],
                ["    return data"],
                ["end procedure"]
            ],
            "english": [
                ["procedure removeFromIndex(index)"],
                ["  if (index is at the front):"],
                ["    call removeFront"],
                ["  else (index is at the back):"],
                ["    call removeBack"],
                ["  else:"],
                ["    if (index is in the front half):"],
                ["      curr points to head"],
                ["      for (i from front to index):"],
                ["        curr moves to next node"],
                ["    else:"],
                ["      curr points to tail"],
                ["      for (i from back to index):"],
                ["        curr moves to previous node"],
                ["    copy data at curr to temp"],
                ["    curr.prev.next points to curr.next"],
                ["    curr.next.prev points to curr.prev"],
                ["    decrement size"],
                ["    return temp"],
                ["end procedure"]
            ]
        }
    },
    "CircularlyLinkedList": {
        "addFront": {
            "code": [
                ["procedure addFront(data)"],
                ["  if size == 0"],
                ["    head ← new Node(data)"],
                ["    head.next ← head"],
                ["  else"],
                ["    Node newNode ← new Node(head.data)"],
                ["    head.data ← data"],
                ["    newNode.next ← head.next"],
                ["    head.next ← newNode"],
                ["  size++"],
                ["end procedure"]
            ],
            "english": [
                ["procedure addFront(data)"],
                ["  if (list is empty):"],
                ["    create newNode node with data"],
                ["    head points to newNode"],
                ["    head.next points to itself"],
                ["  else:"],
                ["    create newNode node with head\"s data"],
                ["    set head\"s data to new data"],
                ["    newNode.next points to head.next"],
                ["    head.next points to newNode"],
                ["  increment size"],
                ["end procedure"]
            ]
        },
        "addBack": {
            "code": [
                ["procedure addBack(data)"],
                ["  addFront(data)"],
                ["  head ← head.next"],
                ["end procedure"]
            ],
            "english": [
                ["procedure addBack(data)"],
                ["  call addFront with data"],
                ["  head moves to next node"],
                ["end procedure"]
            ]
        },
        "addIndex": {
            "code": [
                ["procedure addAtIndex(index, data)"],
                ["  if index == 0"],
                ["    addFront(data)"],
                ["  else if index == size"],
                ["    addBack(data)"],
                ["  else"],
                ["    Node curr ← head"],
                ["    for i ← 0 to index - 2, i++:"],
                ["      curr ← curr.next"],
                ["    Node newNode = new Node(data)"],
                ["    newNode.next ← curr.next"],
                ["    curr.next ← newNode"],
                ["    size++"],
                ["end procedure"]
            ],
            "english": [
                ["procedure addAtIndex(index, data)"],
                ["  if (index is at the front):"],
                ["    call addFront with data"],
                ["  else (index is at the back):"],
                ["    call addBack with data"],
                ["  else:"],
                ["    curr points to head"],
                ["    for (i from front to node before index):"],
                ["      curr moves to next node"],
                ["    create newNode node with data"],
                ["    newNode.next points to curr.next"],
                ["    curr.next points to newNode"],
                ["    increment size"],
                ["end procedure"]
            ]
        },
        "removeFront": {
            "code": [
                ["procedure removeFront()"],
                ["  T data ← head.data"],
                ["  if size == 1"],
                ["    head ← null"],
                ["  else"],
                ["    head.data ← head.next.data"],
                ["    head.next ← head.next.next"],
                ["  size--"],
                ["  return data"],
                ["end procedure"]
            ],
            "english": [
                ["procedure removeFront()"],
                ["  copy data at head to temp"],
                ["  if (list has 1 node):"],
                ["    null out head pointer"],
                ["  else:"],
                ["    copy data at head.next.next to head.data"],
                ["    head.next points to head.next.next"],
                ["  decrement size"],
                ["  return temp"],
                ["end procedure"]
            ]
        },
        "removeBack": {
            "code": [
                ["procedure removeBack()"],
                ["  T data ← null"],
                ["  if size == 1"],
                ["    data ← head.data"],
                ["    head ← null"],
                ["  else"],
                ["    Node curr ← head"],
                ["    for i ← 0 to size - 2"],
                ["      curr ← curr.next"],
                ["    data ← curr.next.data"],
                ["    curr.next ← curr.next.next"],
                ["  size--"],
                ["  return data"],
                ["end procedure"]
            ],
            "english": [
                ["procedure removeBack()"],
                ["  if (list has 1 node):"],
                ["    copy data at head to temp"],
                ["    null out head pointer"],
                ["  else:"],
                ["    curr points to head"],
                ["    for (i from front to node before end):"],
                ["      curr moves to next node"],
                ["    copy data at curr.next to temp"],
                ["    curr.next points to curr.next.next"],
                ["  decrement size"],
                ["  return temp"],
                ["end procedure"]
            ]
        },
        "removeIndex": {
            "code": [
                ["procedure removeIndex(index)"],
                ["  if index == 0"],
                ["    removeFront()"],
                ["  else if index == size - 1"],
                ["    removeBack()"],
                ["  else"],
                ["    Node curr ← head"],
                ["    for i ← 0 to index - 2, i++:"],
                ["      curr ← curr.next"],
                ["    T data ← curr.next.data"],
                ["    curr.next ← curr.next.next"],
                ["    size--"],
                ["    return data"],
                ["end procedure"]
            ],
            "english": [
                ["procedure removeIndex(index)"],
                ["  if (index is at the front):"],
                ["    call removeFront"],
                ["  else (index is at the back):"],
                ["    call removeBack"],
                ["  else:"],
                ["    curr points to head"],
                ["    for (i from front to node before index):"],
                ["      curr moves to next node"],
                ["    copy data at curr.next to temp"],
                ["    curr.next points to curr.next.next"],
                ["    decrement size"],
                ["    return temp"],
                ["end procedure"]
            ]
        }
    }
}